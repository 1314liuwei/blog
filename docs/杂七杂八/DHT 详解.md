# DHT 详解

## DHT 介绍

DHT（分布式哈希表）是一种用于在分布式环境中存储和查找数据的技术。它基于哈希函数将数据映射到一个大型的分布式网络中的节点上。每个节点负责维护一部分数据的索引，并通过协作来实现高效的数据存储和查找。

DHT具有以下几个核心概念：

1. **哈希函数**：DHT使用哈希函数将数据键（key）映射到整个网络中的特定节点。哈希函数将任意长度的输入映射为固定长度的输出，通常是一个数字或字符串。
2. **节点**：DHT网络由多个节点组成，每个节点都有一个唯一的标识符（通常是一个哈希值）和一个网络地址。节点可以加入和离开网络，并且负责存储和处理与其标识符相关联的数据。
3. **数据存储和定位**：当一个节点要存储数据时，它会将数据的键通过哈希函数转换为一个标识符，并找到该标识符在网络中最接近的节点。该节点负责存储该数据项。当需要查找数据时，节点通过哈希函数找到负责该数据项的节点，并从该节点获取数据。
4. **路由表**：每个节点都维护一个路由表，其中包含其他节点的信息。路由表根据标识符的空间划分为不同的区域，使节点能够快速定位到其他节点。通过路由表，节点可以有效地进行消息传递和数据查找。

DHT的优点包括高度可扩展性、去中心化、容错性和灵活性。它可以应用于各种分布式系统场景，如对等网络（P2P）文件共享、内容分发网络（CDN）、分布式存储系统等。

DHT是一个广泛的概念，有许多不同的实现和变体，例如Chord、Kademlia、CAN等。每个实现方式都有其独特的算法和协议，但它们共享相似的基本原则和目标。

## Chord 算法

### 基本要素

Chord 算法的核心在于**一致性哈希算法**和**跳表**。Chord算法将节点 IP 和资源 Key 使用统一用某个哈希函数（如SHA-1）计算出一个 m 位的 ID 号。将计算出的 ID 号对 2^m 取模后按顺序排列在环上，该环被称为 **identifier space**。

对于一个资源 Key ，用哈希函数计算后的 ID 号为 k，该 Key 由环上第一个 ID 号大于 k 的节点负责维护这个资源。

环上的每个节点都维护着自身的后继节点，如下图中，N1 节点保存着 N8 节点的信息，N8 节点保存着 N14 节点的信息，以此类推就构成了一个环形链表结构。

如下图， K10 这个资源就由 N14 这个节点进行负责（14 > 10）。

![img](https://www.researchgate.net/profile/David-Karger/publication/228057545/figure/fig2/AS:302371067449349@1449102288710/figure-fig2.png)



### 资源定位

当节点想要查询一个节点的位置时，根据现有结构，他需要依次遍历每一个后继节点，直到查找到资源为止。

如下图中，节点 N8 想要查找到资源 K54，那么它需要执行 N8 -> N14 -> N21 -> N32 -> N38 -> N42 -> N51 -> N56才能找到 N54 对应的资源。

![image-20230705093922930](http://blog-img-figure.oss-cn-chengdu.aliyuncs.com/img/2023/07/05/20230705-093923.png)

### 引入跳表

为了解决链表结构查询资源缓慢的问题，Chord 引入了 **finger table**，这实际上就是一个跳表。

在 finger table 中，在每个节点 N 上都维护了最多有 m 项（m为 ID 的位数）的路由表（称为 finger table），用来定位资源。

![img](https://www.researchgate.net/profile/David-Karger/publication/228057545/figure/fig5/AS:668680417472520@1536437243266/a-Simple-but-slow-pseudocode-to-find-the-successor-node-of-an-identifier-id-Remote.png)


## Kademlia 算法

